#! /usr/bin/env python
# Copyright 2017 Martin C. Frith

# xxx do lastal & last-train need an option to read-but-ignore fastq data?

import collections
import itertools
import math
import operator
import optparse
import os
import signal
import sys

def floatStr(myFloat):
    return "%.2g" % myFloat

def probCorrectFromAsciiCode(asciiCode):  # fastq-sanger ascii codes
    return 1 - 10 ** (0.1 * (33 - asciiCode))

# Global constants:
qualTable = [probCorrectFromAsciiCode(i) for i in range(128)]
alphabet = "ACGT"
twoStrandAlphabet = alphabet + alphabet.lower()

# Let us use lowercase to represent reverse strands.  For example, a
# lowercase "c" means that, actually, a guanine was observed on the
# reverse strand.

#alphabetMap = [len(alphabet)] * 256
#for i, x in enumerate(alphabet):
#    alphabetMap[ord(x)] = i

def allGenotypes(myAlphabet, ploidy):
    if ploidy:
        for i, x in enumerate(myAlphabet):
            for y in allGenotypes(myAlphabet[i:], ploidy - 1):
                yield x + y
    else:
        yield ""

def conditionalProbsFromPairProbs(pairProbMatrix):  # p(x and y) -> p(y|x)
    for row in pairProbMatrix:
        s = float(sum(row))
        yield [i / s for i in row]

def twoStrandMatrix(oneStrandMatrix):
    for i, j in zip(oneStrandMatrix, reversed(oneStrandMatrix)):
        yield i + j[::-1]

def alignmentProbMatrixFromLastTrain(lines):
    matrix = []
    state = 0
    for line in lines:
        if state == 0:
            if line.startswith("# probability matrix"):
                matrix = []
                state = 1
        else:
            fields = line.split()
            if len(fields) == 2 + len(alphabet):
                matrix.append(map(float, fields[2:]))
            elif not fields:
                state = 0
    return matrix

def alignmentProbMatrixFromLastTrainFile(fileName):
    if fileName == "-":
        matrix = alignmentProbMatrixFromLastTrain(sys.stdin)
    else:
        with open(fileName) as f:
            matrix = alignmentProbMatrixFromLastTrain(f)
    if len(matrix) != len(alphabet):
        raise Exception("can't read last-train file: " + fileName)
    return matrix

def maxPossibleProbRatioPerRefBase(conditionalProbMatrix):
    alphabetLen = len(conditionalProbMatrix)
    for i in range(alphabetLen):  # for each possible reference base
        maxRatio = 1.0
        for j in range(alphabetLen):  # for each possible observed base
            ratio = conditionalProbMatrix[j][j] / conditionalProbMatrix[i][j]
            maxRatio = max(maxRatio, ratio)
        yield maxRatio

def minCoveragePerRefBase(opts, conditionalProbMatrix):
    maxRatios = list(maxPossibleProbRatioPerRefBase(conditionalProbMatrix))
    twoStrandMaxRatios = [max(i) for i in zip(maxRatios, reversed(maxRatios))]
    for i in twoStrandMaxRatios:
        yield int(math.ceil(opts.min / math.log10(i)))

def probsForOneGenotype(baseProbTable, genotype):  # prob(obs. base | genotype)
    ploidy = len(genotype)
    rows = [baseProbTable[alphabet.index(i)] for i in genotype]
    for i in range(len(twoStrandAlphabet)):  # for each possible observed base
        yield sum(r[i] for r in rows) / float(ploidy)

def alignmentColumns(rSeq, qSeq, probLines):
    for i, x in enumerate(rSeq):
        if x != "-":
            yield x + qSeq[i] + "".join(j[i] for j in probLines)

def alignmentWithColumns(alignment):
    rName, beg, end, qName, rSeq, qSeq, probLines, sense = alignment
    columns = list(alignmentColumns(rSeq, qSeq, probLines))
    return rName, beg, end, qName, columns

def mafInput(fileNames):
    if not fileNames:
        fileNames = ["-"]
    for fileName in fileNames:
        if fileName == "-":
            f = sys.stdin
        else:
            f = open(fileName)
        rSeq = qSeq = ""
        sense = None
        probLines = []
        for line in f:
            fields = line.split()
            if line[0] == "a":
                for i in fields:
                    if i.startswith("sense="):
                        sense = float(i[6:])
            elif line[0] == "s":
                if not rSeq:
                    rName = fields[1]
                    beg = int(fields[2])
                    end = beg + int(fields[3])
                    rSeq = fields[6].upper()
                elif not qSeq:
                    qName = fields[1]
                    if fields[4] == "+":
                        qSeq = fields[6].upper()
                    else:
                        qSeq = fields[6].lower()
            elif line[0] == "p":
                probLines.append(fields[1])
            elif not fields:
                if qSeq:
                    yield rName, beg, end, qName, rSeq, qSeq, probLines, sense
                rSeq = qSeq = ""
                sense = None
                probLines = []
        if qSeq:
            yield rName, beg, end, qName, rSeq, qSeq, probLines, sense

def distanceBetweenAlignments(x, y):
    if y[0] != x[0] or y[5].isupper() != x[5].isupper():
        return -1
    if x[5].isupper():
        return y[1] - x[2]
    else:
        return x[1] - y[2]

def isGoodAlignments(opts, alignmentsForOneQuery):
    isGood = True
    if opts.splice is not None:
        isGood = False
        sense = alignmentsForOneQuery[0][7]
        if sense is None:
            raise Exception("missing sense=")
        if abs(sense) < 10:  # xxx hard-coded empirical parameter
            return False
    for j, y in enumerate(alignmentsForOneQuery):
        if j:
            x = alignmentsForOneQuery[j - 1]
            distance = distanceBetweenAlignments(x, y)
            if opts.furthest is not None:
                if distance < 0 or distance > opts.furthest:
                    return False
            if opts.splice is not None:
                if distance >= 0 and distance >= opts.splice:
                    isGood = True
    return isGood

def goodAlignments(opts, alignments):
    for k, v in itertools.groupby(alignments, operator.itemgetter(3)):
        alignmentsForOneQuery = list(v)
        if isGoodAlignments(opts, alignmentsForOneQuery):
            for i in alignmentsForOneQuery:
                yield i

def columnFromAlignment(alignment, coord):
    return alignment[4][coord - alignment[1]]

def columnsFromAlignmentsHere(alignmentsHere, coord):
    for i in alignmentsHere:
        column = columnFromAlignment(i, coord)
        if column[1] in twoStrandAlphabet:
            yield column

def baseIndexAndProbs(column):
    p = 1.0
    for i in column[2:]:
        p *= qualTable[ord(i)]
    return twoStrandAlphabet.index(column[1]), p, 1 - p

def logProbPerGenotype(genotypeProbTable, columns):
    preprocessedColumns = [baseIndexAndProbs(i) for i in columns]
    for row in genotypeProbTable:
        logProb = 0.0
        for baseIndex, p, q in preprocessedColumns:
            logProb += math.log10(p * row[baseIndex] + q)
        yield logProb

def isHeterozygous(genotype):
    return len(genotype) == 2 and genotype[0] != genotype[1]

def alignmentsGroupedByQueryName(alignments):
    d = collections.defaultdict(list)
    for i in alignments:
        d[i[3]].append(i)
    return d

def pairedColumnData(alignments1, coord1, alignments2, coord2):
    g1 = alignmentsGroupedByQueryName(alignments1)
    g2 = alignmentsGroupedByQueryName(alignments2)
    for k in g1:
        if len(g1[k]) == len(g2[k]) == 1:
            c1 = columnFromAlignment(g1[k][0], coord1)
            c2 = columnFromAlignment(g2[k][0], coord2)
            if c1[1] in twoStrandAlphabet and c2[1] in twoStrandAlphabet:
                yield baseIndexAndProbs(c1), baseIndexAndProbs(c2)

def twoSiteLogProb(preprocessedColumnPairs, rowA1, rowA2, rowB1, rowB2):
    r = 0.0
    for i1, i2 in preprocessedColumnPairs:
        y1, p1, q1 = i1
        y2, p2, q2 = i2
        r += math.log10(0.5 * ((p1 * rowA1[y1] + q1) * (p2 * rowA2[y2] + q2) +
                               (p1 * rowB1[y1] + q1) * (p2 * rowB2[y2] + q2)))
    return r

def hetPhase(baseProbTable, genotype1, genotype2, preprocessedColumnPairs):
    x1, y1 = genotype1
    x2, y2 = genotype2
    rowA1 = baseProbTable[alphabet.index(x1)]
    rowA2 = baseProbTable[alphabet.index(x2)]
    rowB1 = baseProbTable[alphabet.index(y1)]
    rowB2 = baseProbTable[alphabet.index(y2)]
    p = twoSiteLogProb(preprocessedColumnPairs, rowA1, rowA2, rowB1, rowB2)
    q = twoSiteLogProb(preprocessedColumnPairs, rowA1, rowB2, rowB1, rowA2)
    if p >= q:
        return x2 + y2, p - q
    else:
        return y2 + x2, q - p

def lastSub(opts, args):
    prog = os.path.basename(sys.argv[0])
    print "#", prog, " ".join(sys.argv[1:])

    # xxx re-do this for each chromosome, to allow different ploidy?
    genotypes = list(allGenotypes(alphabet, opts.ploidy))

    lastTrainFile = args[0]
    pairProbMatrix = alignmentProbMatrixFromLastTrainFile(lastTrainFile)
    conditionalProbMatrix = list(conditionalProbsFromPairProbs(pairProbMatrix))
    minCoverage = list(minCoveragePerRefBase(opts, conditionalProbMatrix))
    baseProbTable = list(twoStrandMatrix(conditionalProbMatrix))
    genotypeProbTable = [list(probsForOneGenotype(baseProbTable, i))
                         for i in genotypes]

    mafFiles = args[1:]
    incomingAlignments = mafInput(mafFiles)
    if opts.splice is not None or opts.furthest is not None:
        incomingAlignments = goodAlignments(opts, incomingAlignments)
    alignments = sorted(incomingAlignments)
    numOfTestedSites = 0
    alignmentCount = len(alignments)
    alignmentPos = 0
    chrom = ""
    coord = 0
    alignmentsHere = []

    oldHetCoord = 0
    oldHetAlignments = []
    oldHetGenotype = "AA"

    while True:
        if not alignmentsHere:
            if alignmentPos == alignmentCount:
                break
            nextAlignment = alignments[alignmentPos]
            chrom = nextAlignment[0]
            coord = nextAlignment[1]
        while alignmentPos < alignmentCount:
            nextAlignment = alignments[alignmentPos]
            if nextAlignment[0] > chrom or nextAlignment[1] > coord:
                break
            alignmentsHere.append(alignmentWithColumns(nextAlignment))
            alignmentPos += 1
        while True:  # xxx bogus loop: what's the right way to do this?
            refBase = columnFromAlignment(alignmentsHere[0], coord)[0]
            if refBase not in alphabet:
                break
            if len(alignmentsHere) < minCoverage[alphabet.index(refBase)]:
                break
            numOfTestedSites += 1
            columns = sorted(columnsFromAlignmentsHere(alignmentsHere, coord))
            if all(i[1].upper() == refBase for i in columns):
                break  # unnecessary, but makes it faster
            logProbs = list(logProbPerGenotype(genotypeProbTable, columns))
            refGenotype = refBase * opts.ploidy
            refLogProb = logProbs[genotypes.index(refGenotype)]
            s = sorted(zip(logProbs, genotypes))
            logProb1, genotype1 = s[-1]
            logProbIncRef = logProb1 - refLogProb
            if logProbIncRef < opts.min:
                break
            logProb2, genotype2 = s[-2]
            logProbInc2nd = logProb1 - logProb2
            if isHeterozygous(genotype1):
                pairs = list(pairedColumnData(oldHetAlignments, oldHetCoord,
                                              alignmentsHere, coord))
                h = hetPhase(baseProbTable, oldHetGenotype, genotype1, pairs)
                phasedGenotype, logProbIncPhase = h
                phaseCoverage = len(pairs)
                oldHetCoord = coord
                oldHetAlignments = alignmentsHere
                oldHetGenotype = phasedGenotype
            else:
                phasedGenotype = genotype1
                logProbIncPhase = 0
                phaseCoverage = 0
            observations = " ".join(i[1:] for i in columns)
            out = (chrom, str(coord), refBase, phasedGenotype,
                   floatStr(logProbIncRef), floatStr(logProbInc2nd), genotype2,
                   floatStr(logProbIncPhase), str(phaseCoverage), observations)
            print "\t".join(out)
            break
        coord += 1
        alignmentsHere = [i for i in alignmentsHere if i[2] > coord]

    print "# Tested sites:", numOfTestedSites

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    usage = "%prog [options] last-train.out alignments.maf"
    descr = "Find nucleotide substitutions relative to a reference genome."
    op = optparse.OptionParser(usage=usage, description=descr)
    op.add_option("-m", "--min", type="float", default=6, metavar="INC", help=
                  "minimum increase in log10(likelihood) over "
                  "homozygous reference (default=%default)")
    op.add_option("-p", "--ploidy", type="int", default=2, metavar="N",
                  help="1=haploid, 2=diploid, etc (default=%default)")
    op.add_option("-f", "--furthest", type="float", metavar="BP", help=
                  "only use query sequences with colinear alignments "
                  "separated by <= BP")
    op.add_option("-s", "--splice", type="float", metavar="BP", help=
                  "only use query sequences with strong splice signals "
                  "and a splice >= BP")
    opts, args = op.parse_args()
    if opts.ploidy < 1:
        op.error("ploidy must be at least 1")
    if not args:
        op.error("I need a last-train file and some MAF alignments")
    lastSub(opts, args)
